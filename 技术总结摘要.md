## 项目摘要

书面版本见 `README.md`

(面试口语回答介绍版本)

这是一个 MIT 课程设计项目，是为了深入理解底层实现，使用 Java 实现核心源码，完成的一个简易关系型数据库系统。

> 其他基本信息：
>
> - 从 7 月 1 日开始，每天大约半个下午的时间，做到 7 月 23 日，累计用时大约 90h

(展开介绍技术亮点)

这个项目实现了很多经典的数据库技术，例如：

- 基于 B+ 树和堆的两种文件组织形式，分页实现数据的访问和存取
- 实现了严格两阶段锁、页级二级锁模式，使用拓扑排序实现了基于资源依赖图的死锁检测
- 实现了 no-steal/force 缓存管理，使用 LRU(最近最少使用)算法实现缓存淘汰策略
- 实现了基于日志的数据库恢复和事务回滚
- 实现了基于代价的查询优化，使用动态规划算法对多表连接的代价估算，求出较优的多表连接顺序，以及使用直方图估计各列的选择性

## 技术梳理

1. Lab1 文件读写
   1. Exercise1 实现 `Tuple`, `TupleDesc` 即数据表一行数据及其表头定义
   2. Exercise2 实现 `Catalog` 维护所有数据表
   3. Exercise3 实现 `BufferPool` 读取页面
   4. Exercise4 实现 `HeapPage` 读取堆文件具体一页
   5. Exercise5 实现 `HeapFile` 读取堆文件，遍历每一行
   6. Exercise6 实现 `SeqScan` 遍历数据表每行
2. Lab2 增删改查
   1. Exercise1 实现 `Predicate`, `Filter` 即查询里的 `where` 不等式判断
   2. Exercise2 实现 `Aggregator` 即 `group by` 和诸如 `sum, min` 等聚合运算
   3. Exercise3 实现增删行，标记脏页
   4. Exercise4 实现 `Insert`, `Delete` 操作符
   5. Exercise5 实现页面置换算法
3. Lab3 查询优化
   1. Exercise1 实现 `IntHistogram` 直方图评估单列范围查询的选择性
   1. Exercise2 实现 `TableStats` 预处理实现快速对选择性等的查询
   1. Exercise3 实现基于启发式的对 join 后元素数评估
   1. Exercise4 实现基于动态规划的对 join 顺序优化
4. Lab4 事务管理
   1. Exercise1 实现页级共享\&排他锁申请与释放
   2. Exercise2 实现严格两阶段锁
   3. Exercise3 实现no-steal/force下脏页取消置换
   4. Exercise4 实现事务完成和事务回滚
   5. Exercise5 实现基于拓扑排序的死锁检测、死锁解除

5. Lab5 索引优化
   1. Exercise1 实现 B+ 树搜索
   2. Exercise2 实现 B+ 树插入节点
   3. Exercise3 实现 B+ 树删除叶节点
   4. Exercise4 实现 B+ 树删除内部节点

6. Lab6 日志管理
   1. Exercise1 实现基于日志的事务回滚
   2. Exercise2 实现检查点与数据库恢复


### Lab1

每个表格有每列的描述(`TupleDesc`)，每一行由一个 `Tuple` 定义。

数据库有单例 `Database` 对象，下拥有：

-  `Catalog` 单例，维护所有的数据表。

- `BufferPool` 单例，缓存所有页。

  LRU 个人实现：维护每个页面(`PageId`)对应的最后访问时间，找到时间戳最小的返回删除。

  后续修改：求最小时跳过脏页，脏页不能被放回。

堆式文件组织：每页 4096 字节，每页头部有 bool 数组(位示图)，表示某行是否有效，长度为 8 的倍数。使用 LSB(最右是最低有效位)代表第一行。

> JVM 是大端存储的，意味着对 0x1234 若分两个地址存低存 0x12，高存 0x34

对每一行的存储，若 tuple 占 X 位，它的位示图占 1 位，加起来一个 tuple 前后占 X+1，所以整除下取整得到每页能存的 tuple 数。

> 这样有空位的页好处是方便增删(删除不用挪动后边的)。

### Lab2

熟练使用迭代器，朴素遍历，即可完成 where 和 group by。

增加行找到第一个空位示图对应的，找不到开新页，将动过的页/新页标脏；删除就遍历找到要删的那行所在页。增删只标脏，暂不写回磁盘，页面置换时才将更新写回磁盘。

### Lab3

#### CBO简介

实现基于成本的优化器。SQL 执行 [参考](https://blog.csdn.net/weixin_45938441/article/details/128447702) 过程。

- 基于规则的优化器 RBO, rule based optimizer，如早期 Oracle

  每个规则一个优先级，低级路径效率认为更高，选择所有可能的最低路径

- 基于成本的优化器 CBO, cost based optimizer

  求 SQL 执行的代价，找代价低的去执行

  成本包括：

  - I/O 成本。磁盘读取，经验时间 1/80 秒

  - CPU 成本

    - CPU 基本成本(base cost)，不依赖对象大小的固定值。

    - CPU 页成本(page cost)，从缓存池找到一页。

    - CPU 扫描成本(scan cost)，对一页的行进行可索引谓词扫描。

      如其中 `were id=1` 可以索引优化，`where id!=1` 不可以优化

    - CPU 行成本(row cost)，将符合条件的行复制到内存、对不可索引谓词进一步筛选

  本 lab 只关注 CPU 的连接、访问成本。

基数 cardinality：某一列中，所有可能的取值集合的大小。如性别为 2。

选择性 selectivity：基数÷行数。

- 意义：衡量索引的效率。如使用性别做索引选择性低表明意义不大，使用学号做索引选择性高，主键选择性一定是 1。

  某个查询计划选择性高，证明 `where` 后能更好去掉不满足条件的列，从而达到查询优化的效果。

整体流程如图所示：

<img width=400 src="img/lab3-controlflow.png">

#### 直方图评估选择性

评估一次查询耗费的时长，以此调整连表顺序优化查询。

- `scancost` 是 I/O 读盘花费，设为页数乘常数。

- `joincost` 是 CPU 做连接运算花费，不考虑 cache 时，设为 where 运算花费乘常数。

- 多 join 的总耗费，按照连接顺序，为：
  $$
  \sum scancost(t_i)+joincost(t1,t2)+joincost((t1,t2),t3)+\cdots
  $$
  具体而言，有：
  $$
  joincost(t1,t2)=scancost(t1)+n(t1) scancost(t2)+n(t1)n(t2)
  $$
  其中行数 $n$ 可以扫描一遍算出来；$n(t1)n(t2)$ 是 CPU 花费，其他是 I/O

$n(t1,t2)$ 不好计算，一种柱状图估算方法如下：

1. 对一个数据表，扫描一次，求出每个列属性的最大最小值

2. 设常数 $NumB$，将每列值域分为 $NumB$ 块，频数分布直方图

3. 对 `where col=C` 查询，设值 $C$ 所在块有 $h$ 行数据，该块值域为 $w$，整个表有 $ntups$ 行，假设均匀分布，则每个元素等于 $C$ 的概率为 $\dfrac{h}{w\cdot ntups}$

4. 对 `where col>C` 查询，设 $C$ 所在桶值域长 $w_b$，有 $h_b$ 行，最大值是 $b_r$，则这个桶内比 $C$ 大的相对宽度为 $b_p=\dfrac{b_r-C}{w_b}$，桶内有 $b_f=\dfrac{h_b}{ntups}$ 的百分比元素含量，所以这个桶贡献 $b_fb_p$

   且比它大的所有桶都符合，即往后遍历全部桶，加上 $\sum \dfrac{h_j}{ntups}$。

5. 对其他不等式关系，可以规化到上面两种情况

使用分块思想模拟可以实现单列柱状图。对每个参与查询的表格，预处理各列柱状图。

#### 启发式评估join

对 join 后元素数的评估，根据经验分类讨论，启发式方法：

1. `where A=B`

   1. A 是主键，B 也是主键，则最坏情况一一对应，取 $\min(n(A),n(B))$
   2. A 是主键，B 不是主键，最坏情况 B 全等于 A 某键，取 $n(B)$
   3. A 不是主键，B 是主键，同理 $n(A)$
   4. A,B 都不是主键，最坏情况多的那方全等于少的某个键，取 $\max(n(A),n(B))$

2. 其他情况

   很难直接计算，故直接设选择性为 $0.3$，认为结果大小 $0.3n(A)n(B)$

#### DP优化join顺序

join 顺序优化：

> 以 $r_1\bowtie r_2\bowtie r_3$ 为例，有：$r_1\bowtie(r_2\bowtie r_3),r_1\bowtie(r_3\bowtie r_2),(r_1\bowtie r_3)\bowtie r_2$ 等共 $12$ 种连接顺序，具体而言有 $\dfrac{(2(n-1))!}{(n-1)!}$ 种连接顺序
>
> 证明：考虑卡特兰数，$n$ 个运算的顺序可以表示为 $n-1$ 对括号，即 $C_{n}=\dfrac{C(2n,n)}{n+1}=\dfrac{(2n)!}{n!^2(n+1)}$，然后再乘以全排列即：
> $$
> n!C_{n-1}=\dfrac{(2(n-1))!}{(n-1)!^2n}n!=\dfrac{(2(n-1))!}{(n-1)!^2n}(n-1)!n=\dfrac{(2(n-1))!}{(n-1)!}
> $$

然而实际搜索时，对每个方案，并不一定要枚举全部可能性，例如对如下方案 $(r_1\bowtie r_2\bowtie r_3)\bowtie r_4\bowtie r_5$

如果可以用 $12$ 次枚举求出 $r_1\bowtie r_2\bowtie r_3$ 的最优解，然后问题规划为 $r'\bowtie r_4\bowtie r_5$ 的最优解，又是 $12$ 次枚举，故一共只需要 $12+12$ 次枚举。

这就是动态规划的思想。具体而言，枚举每个子集 $s$，然后对 $s$ 枚举所有一步能到达它的最优解，找到 $s$ 的最优解。 也就是枚举子集型暴力 DFS。



### Lab4

#### 页级二级锁模式

事务满足 ACID，其中：

- 隔离性：并发执行的各个事务不能互相干扰。

  执行调度可串行化，使用锁保护共享对象。

为了提高效率(读的时候可以被其他读，而不是只能被一个读)，将锁细分为共享锁、排他锁。

考虑锁的粒度为页级锁。(行级维护锁的代价太大)

具体到 lab 实现，维护每个锁被多少个事务共享占有(要用并发集合)，被哪个事务排斥占有，和一系列对应方法，然后对每个页，维护它对应的锁。

#### 两阶段锁

> 加锁不能让原本不可串行的调度正确，例如下面将破坏隔离性：[参考](https://zhuanlan.zhihu.com/p/480379228)
>
> ```
> T1 BEGIN
> T1 X-LOCK(A) # 排他锁
> T1 R(A)
> T1 W(A)
> T1 UNLOCK(A)
> 
> T2 BEGIN
> T2 X-LOCK(A)
> T2 W(A)
> T2 UNLOCK(A)
> 
> T1 S-LOCK(A)
> T1 R(A) #被T2修改了,T1之前的W(A)被覆盖了
> T1 UNLOCK(A)
> T1 COMMIT
> T2 COMMIT
> ```

> 上例，依赖图：T2 依赖 T1，表示必须等待释放排他锁。
>
> 上例不一定破坏一致性，因为一致性由完整性约束如主键约束、外键约束等维护。但也其他例子可以破坏一致性：
>
> ```
> T1 BEGIN #转账
> T1 X-LOCK(A)
> T1 R(A) #1000
> 
> T2 BEGIN #读金额总数
> T2 S-LOCK(A)
> 
> T1 A=A-100
> T1 W(A)
> T1 UNLOCK(A)
> 
> T2 R(A) #1000
> T2 UNLOCK(A)
> T2 S-LOCK(B)
> 
> T1 X-LOCK(B)
> 
> T2 R(B) #1000
> T2 UNLOCK(B)
> T2 ECHO A+B #900+1000
> T2 COMMIT
> 
> T1 R(B)
> T1 B=B+100
> T1 W(B) #1100
> T1 UNLOCK(B)
> T1 COMMIT
> ```

为了解决这个问题，提出两阶段锁(two-phase locking, 2PL)这一并发控制协议，目的是实现可串行化。

使用两阶段锁不需要提前知道完整的执行调度，它会在调度进行的过程中避免不可串行化的情况发生。

阶段：

- 增长 growing。只能不断地获得锁，不能释放锁。
- 缩小 shrinking。只能释放释放锁，不能再获取新的锁。

> 根据两阶段，上例第五行不允许 T1 释放锁，从而保证了正确性。

在使用了二阶段锁协议后，相应的执行调度对应的依赖图（Dependency Graph）一定没有环，二阶段锁可以严格地保证冲突可串行化。

两阶段锁的问题：级联回滚（Cascading Aborts）

> 考虑 T1 修改了 A,B，然后释放了 A 还没释放 B，T2 随后又修改了 A，但是最后 T1 事务丢弃了，这会导致 T2 修改无效(脏读)。

为此引入了严格两阶段锁(Strong Strict 2PL, SS2PL)，要求：

- 事务所修改的数据在事务结束之前，其他事务都不能读写。避免了脏读。

这样就不会因为脏读而级联回滚。

严格两阶段锁不能解锁死锁问题。考虑：

```
T1 BEGIN
T1 X-LOCK(A)
T2 BEGIN
T2 S-LOCK(B)
T2 R(B)
T2 S-LOCK(A) #wait

T1 R(A)
T1 X-LOCK(B) #wait
```

#### 死锁

> OS 的死锁处理方法有：

> - 死锁预防。破坏请求保持(一次性申请)、破坏不可剥夺、破坏循环等待(编号)
> - 死锁避免。银行家算法。若分配不会导致进入不安全状态就分配，否则等待。
> - 死锁检测。死锁定理(不可完全简化=死锁) -> 死锁解除。

具体到数据库死锁检测：

死锁处理方法：维护锁等待图(节点是事务，$u\to v$ 表示 $u$ 等待 $v$ 释放锁)，周期性判断图是否成环(如本lab采用：拓扑排序)，如果成环，选一个事务回滚(本lab:如果加入当前事务产生了死锁，那么就abort掉当前事务)。

- 完全回滚。被选事务完全取消，回到执行前状态。(本lab采用)
- 最小化回滚。判断事务导致死锁的语句，回滚这些语句。

> 死锁避免方法：规定越先开始优先级越高。
>
> - wait-die。高优先级事务想要低优先级事务的锁，等待；低优先级想要获得，不给获得直接回滚。
> - wound-wait。高优先级想得低优先级，低优先级回滚；低优先级想要获得，等待高优先级。



#### no-steal/force

steal 策略(policy)：是否允许在事务提交前，对某页的修改写回磁盘？

- 允许，steal。如果事务成功影响不大，如果事务回滚，需要读盘、撤销更新、再写盘，I/O 高。
- 不允许，no-steal。一个事务可能修改很多页，导致缓存池装不下，内存浪费，效率更低。

是否 steal 是对数据恢复时间与处理效率的衡量。



force 策略：事务提交后，是否马上将对某页的修改写回磁盘？

- 是，force。一致性好保证，但频繁读写 I/O 效率不高。
- 否，no-force。延迟写盘，数据一致性可能存在问题，但 I/O 效率较高。



根据这两个问题回答的情况，有四种组合策略。在实践里，常用 no-steal/force 和 steal/no-force。



no-steal/force 组合好实现。

- no-steal：如果事务放弃，不需要真的磁盘里一个个写回去，只需要将缓存池脏页全丢了，这些页被其他事务读时再读盘即可。
- force：数据库崩溃时，因为事务一旦提交已经写盘，所以所有成功事务不需要重做。

优点：

- 事务进行时数据库崩溃，恢复时不需要 undo 和 redo。

缺点：

- 所有事务保存到内存，降低并发量。不能让事务操作的数据量超过缓存池大小。



no-steal表示未commit的事务不允许将修改写回磁盘，使得abort不需要磁盘回滚。force表示在事务commit必须马上将更新写回磁盘，则即使之后数据库崩溃commit也存在磁盘了。

no steal 的好处是，如果要放弃一个事务，只需要丢弃全部脏页，重新从磁盘读取即可，而不需要真的反向回滚每条指令。因此，必须保证，事务没完成之前，所有的脏页不给读盘。

> 一种其他策略：steal/no-force。就是事务结束不刷盘，只刷日志不刷页，刷盘时记录日志。



### Lab5

m 阶 B 树是满足下面条件的多叉排序树：

- 非叶子节点子树数目不超过 $m$
- 非叶子节点、非根节点的子树数目不低于 $\lceil\dfrac m2\rceil$
- 根节点至少有两棵子树
- 若非叶子节点有 $n$ 个关键码，则有 $n+1$ 个子树，且关键码单调递增，第 $i$ 个子树关键码小于第 $i$ 个，大于第 $i-1$ 个关键码

m 阶 B+ 树与 B 树区别如下：

- 所有叶子节点包含了全部关键字，按照关键字顺序连接
- 非叶子节点统一包含子树的左最大关键字或右最小关键字(lab实现了后者)

对二叉树的遍历，对每个节点，顺序或二分枚举所有关键字(影响不大，因为阶就 500 左右)，枚举性能不是瓶颈，比读盘快多了，所以怎么枚举不重要。直到叶子节点为止。

插入节点，如果插入后页满了：

1. 如果父不满，父增加一个 key，子对半分裂
2. 父满了，父同理分裂，往上递归
3. 根节点满了，创建新内部节点做根节点

注意维护链表、脏页和其他表相关数据一致性。

删除节点，如果删完了少于一半：

- 从兄弟节点拿一个过来，如果不能拿就与兄弟合并
- 合并后删掉父的一个关键字，如果父少于一半递归处理
- 如果到根了，删掉根节点



### Lab6

基于 steal/no-force 的日志管理。[参考](https://blog.csdn.net/weixin_45938441/article/details/128729077)

- steal：日志写检查点函数时会强制清空缓存池，该清空会引发未提交事务脏页写盘、同时写日志。清空完毕后标记日志检查点。

  由于事务锁的存在，检查点记录并不会重新导致脏读问题。但是新增加的问题是事务中断需要读日志回滚用旧数据写盘。

- no-force：事务结束不刷盘，只刷日志不刷页，刷盘时记录日志。

  代码中事务还是 force 的，但是这里实现的日志可以支持到 no-force。

日记由事务开始、事务完成、事务丢弃、页更新(日记里附上新旧页数据)、检查点五种类型的数据组成流文件。且开头记录最后一个检查点的位置。维护一个 map 表示每个未完成、尚未知道是否commit/abort的事务对应的日记开始位置。

检查点强制存盘，且强制清空缓存池。表示意义是这个点之前都能保证正确。

实现回滚：从日志未完成事务集合 map 找该事务起始点开始读，读每个页面，然后按读的逆序将每个页面写盘。因为测试用例会steal，一个页面就会写盘多次，则以最后一次为准。

数据库恢复时，从检查点/(无检查点)开头读，读到事务开始就插入到 map，读到事务成功/回滚就从这里移除。如读到了回滚，可以忽略，并从 map 删掉，因为如果写了回滚，那么一定已经执行成功了回滚，不需要额外操作。

之后从检查点往后读，记录所有成功事务；然后对每个在 map 但不在成功里的事务，按日记顺序读旧页，一个一个逆序写回去。逐个事务遍历，不能一次遍历写回去。在这之后，对成功提交事务，重新执行一遍。 