# 开发过程笔记

## Lab1

### Exercise1

#### 任务要求

阅读文档 `lab1.md` 可知，需要完成 `storage` 包的 `Tuple.java` 和 `TupleDesc.java` 两个类的补充编写，通过 `TupleTest` 和 `TupleDescTest`。

阅读源码，根据相关知识推断，`TupleDesc` 是一张数据表的各列的声明(description)，其中，要手写的数据库支持两种数据类型(参见 `common.Type` 枚举类)，其中 `INT_TYPE` 长度为 $4$ 位，定长字符串类 `STRING_TYPE` 长为 $len+4$ 位。这两种数据类型的父类是 `common.Field`，子类是 `IntField` 和 `StringField`。基本的方法已经写好，包括比较、构造、取值等。且 `TupleDesc` 有一个静态内部类 `TDItem`，有 `Type fieldType` 和 `String fieldName` 两个属性。

`TupleDesc` 未实现的方法有：

- 构造函数 `public TupleDesc(Type[] typeAr, String[] fieldAr)`

  `public TupleDesc(Type[] typeAr)`

- 取字段数 `public int numFields()`

- 取各字段迭代器 ` public Iterator<TDItem> iterator()`

- 取特定字段 `public String getFieldName(int i) throws NoSuchElementException`

  `public Type getFieldType(int i) throws NoSuchElementException`

- 取字段下标 `public int indexForFieldName(String name) throws NoSuchElementException`。注意传 null 要 throw。如果字段未命名要 throw。

- 取大小 `public int getSize()` (bytes) 即各字段的大小之和

- 合并字段 `public static TupleDesc merge(TupleDesc td1, TupleDesc td2)`，直接有序拼接

- 判断相等 `public boolean equals(Object o)`

- 与 null / object 不等；自己与自己相等，字段同样相等

- 输出 `public String toString()`

阅读 `TupleDescTest` 单元测试类，核实需要做的功能：

- `public void getType()` 检查每个字段是否正确，支持 1000 个字段，下同
- `public void nameToId()` 检查每个字段命名是否正确
- `public void getSize()` 
- `ublic void numFields()`
- `public void testEquals()`
- `public void combine()`

`RecordId` 是一个未实现类。暂时按下不表。`Tuple` 是对应数据库的一行，维护表头描述和具体值。

`Tuple` 未实现的方法有：

- 构造函数 `public Tuple(TupleDesc td)`

- 取字段描述 `public TupleDesc getTupleDesc()`

- 取该表在磁盘的记录号 `public RecordId getRecordId()`

- 设置特定字段 `public void setField(int i, Field f)`

  `public Field getField(int i)`

- `public String toString() `

- 取所有值 `public Iterator<Field> fields()`

- 重新设置 `public void resetTupleDesc(TupleDesc td)`

`TupleTest` 单元测试要完成的功能：

- `public void modifyFields()`
- `public void getTupleDesc()`
- `public void modifyRecordId()` (暂时不管)

#### 具体实现

##### TupleDesc

考虑到 `TupleDesc` 的少修改性质，使用直接的 `ArrayList` 或静态数组能达成 $O(1)$ 的询问，所以直接用其小模拟上述的 CRUD 即可。考虑到方便性，且 `ArrayList` 与静态数组的性能常数差别不大，这里考虑使用 `ArrayList`。

考虑到可能频繁的查询需求，这里对判断相等、根据列名取下标进行了预处理(使用了哈希表)，以多一倍的空间代价换取了高效的时间代价。具体而言，除了构造函数、合并(`combine`)和输出(`toString`)外，所有其他 `TupleDesc` 的函数实现，即：`numFields, iterator, getFiledName, getFieldType, indexForFieldName, getSize, equals` 函数都完成了 $O(1)$ 的实现。

使用的内部成员变量为：

```java
private ArrayList<TDItem> items;
private int size; // 预处理
private int hashCode; // 预处理
private HashMap<String, Integer> name2index; // 预处理
```

特别地，为 `TDItem` 类新增了 `hashCode` 方法，以支持 $O(1)$ 的 equals 实现。具体哈希函数为：

```java
@Override
public int hashCode() {
    if (fieldName == null) {
        return 0;
    }
    return fieldName.hashCode() * (fieldType == Type.INT_TYPE ? 7 : 11);
}
```

其中 7 和 11 是两个质数，能比较好地减少冲突。如果后续还需要反复对 `Type` 类求冲突，则将考虑会把 `hashCode` 函数写到 `Type` 去。

综上所述，`TableDesc` 本质上还是一个简单朴素的 CRUD 小模拟，很好实现。详见源码。



### Exercise2

#### 任务要求

`common.Database` 是一个饿汉单例模式，拥有一个 `Catalog _catalog` 和其他内容(后续再说)。`DbFile` 是一个接口，表示一个磁盘的数据库文件。

支持的方法：

- 构造函数 `public Catalog()`

- 添加数据表 `public void addTable(DbFile file, String name, String pkeyField)` (第三个参数时主键名字)

  `public void addTable(DbFile file, String name)`

  `public void addTable(DbFile file)`

- 取数据表 `public int getTableId(String name) throws NoSuchElementException`，其中 table id 是随机的(不是 auto increment)，注意判 null。重复 table name 但不同 table id 可以允许

  `public Iterator<Integer> tableIdIterator()`

  `public TupleDesc getTupleDesc(int tableid) throws NoSuchElementException`

  `public DbFile getDatabaseFile(int tableid) throws NoSuchElementException`

  ` public String getPrimaryKey(int tableid)`

- 取数据表id遍历器 `public Iterator<Integer> tableIdIterator()`

- 清空 `public void clear()`



单元测试 `CatalogTest` 要完成的任务：

- 新建两表格 `@Before public void addTables()` 
- `public void getTupleDesc()` 
- `public void getTableId()`
- `public void getDatabaseFile()`
- `public void handleDuplicateNames()` 重复 table name 但不同 table id 可以允许
- `public void handleDuplicateIds()` 重复 table id 覆盖旧的



### Exercise3

#### 任务要求

`Database` 单例有 `BufferPool _bufferpool`，

 