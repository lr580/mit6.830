# 开发过程笔记

## Lab1

### Exercise1

#### 任务要求

阅读文档 `lab1.md` 可知，需要完成 `storage` 包的 `Tuple.java` 和 `TupleDesc.java` 两个类的补充编写，通过 `TupleTest` 和 `TupleDescTest`。

阅读源码，根据相关知识推断，`TupleDesc` 是一张数据表的各列的声明(description)，其中，要手写的数据库支持两种数据类型(参见 `common.Type` 枚举类)，其中 `INT_TYPE` 长度为 $4$ 位，定长字符串类 `STRING_TYPE` 长为 $128+4$ 位，恒只有 $128$ 个字符。这两种数据类型的父类是 `common.Field`，子类是 `IntField` 和 `StringField`。基本的方法已经写好，包括比较、构造、取值等。且 `TupleDesc` 有一个静态内部类 `TDItem`，有 `Type fieldType` 和 `String fieldName` 两个属性。

`TupleDesc` 未实现的方法有：

- 构造函数 `public TupleDesc(Type[] typeAr, String[] fieldAr)`

  `public TupleDesc(Type[] typeAr)`

- 取字段数 `public int numFields()`

- 取各字段迭代器 ` public Iterator<TDItem> iterator()`

- 取特定字段 `public String getFieldName(int i) throws NoSuchElementException`

  `public Type getFieldType(int i) throws NoSuchElementException`

- 取字段下标 `public int indexForFieldName(String name) throws NoSuchElementException`。注意传 null 要 throw。如果字段未命名要 throw。

- 取大小 `public int getSize()` (bytes) 即各字段的大小之和

- 合并字段 `public static TupleDesc merge(TupleDesc td1, TupleDesc td2)`，直接有序拼接

- 判断相等 `public boolean equals(Object o)`

- 与 null / object 不等；自己与自己相等，字段同样相等

- 输出 `public String toString()`

阅读 `TupleDescTest` 单元测试类，核实需要做的功能：

- `public void getType()` 检查每个字段是否正确，支持 1000 个字段，下同
- `public void nameToId()` 检查每个字段命名是否正确
- `public void getSize()` 
- `ublic void numFields()`
- `public void testEquals()`
- `public void combine()`

`RecordId` 是一个未实现类。暂时按下不表。`Tuple` 是对应数据库的一行，维护表头描述和具体值。

`Tuple` 未实现的方法有：

- 构造函数 `public Tuple(TupleDesc td)`

- 取字段描述 `public TupleDesc getTupleDesc()`

- 取该表在磁盘的记录号 `public RecordId getRecordId()`

- 设置特定字段 `public void setField(int i, Field f)`

  `public Field getField(int i)`

- `public String toString() `

- 取所有值 `public Iterator<Field> fields()`

- 重新设置 `public void resetTupleDesc(TupleDesc td)`

`TupleTest` 单元测试要完成的功能：

- `public void modifyFields()`
- `public void getTupleDesc()`
- `public void modifyRecordId()` (暂时不管)

#### 具体实现

##### TupleDesc

考虑到 `TupleDesc` 的少修改性质，使用直接的 `ArrayList` 或静态数组能达成 $O(1)$ 的询问，所以直接用其小模拟上述的 CRUD 即可。考虑到方便性，且 `ArrayList` 与静态数组的性能常数差别不大，这里考虑使用 `ArrayList`。

考虑到可能频繁的查询需求，这里对判断相等、根据列名取下标进行了预处理(使用了哈希表)，以多一倍的空间代价换取了高效的时间代价。具体而言，除了构造函数、合并(`combine`)和输出(`toString`)外，所有其他 `TupleDesc` 的函数实现，即：`numFields, iterator, getFiledName, getFieldType, indexForFieldName, getSize, equals` 函数都完成了 $O(1)$ 的实现。

使用的内部成员变量为：

```java
private ArrayList<TDItem> items;
private int size; // 预处理
private int hashCode; // 预处理
private HashMap<String, Integer> name2index; // 预处理
```

特别地，为 `TDItem` 类新增了 `hashCode` 方法，以支持 $O(1)$ 的 equals 实现。具体哈希函数为：

```java
@Override
public int hashCode() {
    if (fieldName == null) {
        return 0;
    }
    return fieldName.hashCode() * (fieldType == Type.INT_TYPE ? 7 : 11);
}
```

其中 7 和 11 是两个质数，能比较好地减少冲突。如果后续还需要反复对 `Type` 类求冲突，则将考虑会把 `hashCode` 函数写到 `Type` 去。

综上所述，`TableDesc` 本质上还是一个简单朴素的 CRUD 小模拟，很好实现。详见源码。

##### Tuple

不考虑 `RecordId`，那么剩下的事情就是同理，加成员属性：

```c++
private TupleDesc tupleDesc;
private ArrayList<Field> fields;
```

实现对其的初始化和查询修改即可。

> 对于代码注释给定的 `only affecting the TupleDesc`，我个人的理解是只需要修改 `tupleDesc` 而不用管 `fields`，我暂时没看到 `resetTupleDesc` 在单元测试出现，所以不知道它具体会用来干嘛，如果以后这里出错了，再修改一下，改成把 `fields` 也重新刷新一遍即可。



### Exercise2

#### 任务要求

`common.Database` 是一个饿汉单例模式，拥有一个 `Catalog _catalog` 和其他内容(后续再说)。`DbFile` 是一个接口，表示一个磁盘的数据库文件。

> 具体而言，`DbFile` 接口提供的方法如下：
>
> - `TupleDesc getTupleDesc()`
>
> - `int getId()` 唯一标识 `HeapFile` 的 ID
>
> - `DbFileIterator iterator(TransactionId tid)` 
>
>   其中 `DbFileIterator` 是遍历所有 `Tuple` 的迭代器，有 `open(), hasNext(), next(), rewind(), close()` 方法
>
>   `TransactionId` 标识事务 ID，其 ID 通过静态类原子计数器自增，即每次构造函数得到唯一自增的整数 long 作为事务 ID，通过 `public long getId()` 取出
>
> - `Page readPage(PageId id)` 读取磁盘的一页
>
>   其中 `PageId` 是接口，有 `int getTableId()`, `int getPageNumber()` 等方法
>
>   `Page` 是接口，有 `PageId getId()`, `byte[] getPageData()` 等方法
>
> - `void writePage(Page p)`
>
> - `List<Page> insertTuple(TransactionId tid, Tuple t)`
>
> - `List<Page> deleteTuple(TransactionId tid, Tuple t)`

`Catalog` 支持的方法：

- 构造函数 `public Catalog()`

- 添加数据表 `public void addTable(DbFile file, String name, String pkeyField)` (第三个参数时主键名字)

  `public void addTable(DbFile file, String name)`

  `public void addTable(DbFile file)`

  name 不能 null，可以空串；冲突时覆盖被冲突者

- 取数据表 `public int getTableId(String name) throws NoSuchElementException`，其中 table id 是随机的(不是 auto increment)，注意判 null。重复 table name 但不同 table id 可以允许

  `public Iterator<Integer> tableIdIterator()`

  `public TupleDesc getTupleDesc(int tableid) throws NoSuchElementException`

  `public DbFile getDatabaseFile(int tableid) throws NoSuchElementException`

  ` public String getPrimaryKey(int tableid)`

- 取数据表id遍历器 `public Iterator<Integer> tableIdIterator()`

- 清空 `public void clear()`

单元测试 `CatalogTest` 要完成的任务：

- 新建两表格 `@Before public void addTables()` 
- `public void getTupleDesc()` 
- `public void getTableId()`
- `public void getDatabaseFile()`
- `public void handleDuplicateNames()` 重复 table name 但不同 table id 可以允许，新 id 覆盖旧 id。
- `public void handleDuplicateIds()` 重复 table id 不同 table name 可以允许，新 name 覆盖旧 name

#### 具体实现

考虑用 name 或 id 作键，`DBFile` 做值的 `HashSet`，能够满足功能需求，也符合实际含义。且 `DBFile` 能导出要求的 `TupleDesc`。考虑迭代器需求，用 id 作键，像 `TDItem` 一样做一个 name, 主键和 `DBFile` 三元组，且反向再用 name 做键对 id。对冲突讨论：

1. 新增重复 name 不同 id，会修改反向 `HashSet`，但通过 id 仍能找到旧表，所以要手动删掉旧表
2. 新增重复 id 不同 name，直接修改 `HashSet`，但反向能找到旧的无效 id，所以要手动删掉旧表
3. 新增重复 name 重复 id，两边都删。

总结逻辑为：先删重复 id 和重复 name，之后再插入。

新增的内部类为：

```java
public static class TableItem implements Serializable {
    public final DbFile dbFile;
    public final String name;
    public final String primaryKey;
}
```

新增的成员变量为：

```java
private HashMap<Integer, TableItem> tables;
private HashMap<String, Integer> name2tableId;
```

同理，空间换时间，增加一点(不是一倍，`TupleDesc` 同理，两个 map 显然空间不一样)的空间，换取更优的时间效率，但是维护修改的代价也有所增大。



### Exercise3

#### 任务要求

`Database` 单例有 `BufferPool _bufferpool`，

 